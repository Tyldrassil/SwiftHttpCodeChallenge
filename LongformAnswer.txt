Planning for failure

Unhappy customer 1

At first i though this might be due to a timeout error on the client side, a lack of a response for too long leading to code not being run. However if we assume that all three unhappy customers happen on the same codebase (as we should) then the second unhappy customer should also have a timeout error

Therefore i think that That there might be an mistake in error/success code handling. If the payment API replies back with a non 200 success code, and your code doesn't know to show a success message in this scenario. This would be a match. Maybe a 202 code for "Accepted" was sent due to the server load instead of a 200 "OK" code

This would then be fixed by correctly handling the success code


Unhappy customer 2

I imagine that this could be due to a race condition. If the front end of the website sends a request to the backend of the website at the exact wrong moment, the customers payment data could be used for two separate calls to the payment API, resulting in two charges.

This would be solved by keeping a greater control on the backend of the server concurrency to make sure these race conditions are possible.



Unhappy customer 3

While this could be seen as a complete user error. After all the user did hit the submit button more than once. This is still a fault of the programmers, due to not checking for this case happening ahead of time. 

This wouldn't create two orders in the system, due to creating an identical addition to the database, possibly overwriting the previous instance

I feel this would be simplest fixed by preventing the submit button from activating more than once before the device gets a reply from the server.

An addition i would also implement in this situation would also to add some sort of progress indicator for the user. Just so the user is not frustrated with the lack of sign of progress in the system or device. Alternatively adding in a message about the large amount of server load could help alleviate frustration from the user.